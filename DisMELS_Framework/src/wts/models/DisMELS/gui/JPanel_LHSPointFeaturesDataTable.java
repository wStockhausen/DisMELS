/*
 * CSVDataTable_JPanel.java
 *
 *  Provides gui functionality for a CSVDataSource using a JPanel setting
 *
 * Created on March 5, 2003, 6:41 PM
 */

package wts.models.DisMELS.gui;

/**
 *
 * @author  William Stockhausen
 */

import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.IOException;
import java.util.logging.Logger;
import javax.swing.JTable;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.TableColumn;
import javax.swing.table.TableColumnModel;
import javax.swing.table.TableModel;
import org.geotools.feature.Feature;
import org.geotools.feature.FeatureCollection;
import wts.models.DisMELS.framework.LHSPointFeatureType;


/** Provides a JPanel interface to a CSVDataSource and derived DataTableModel
 *
 */
public class JPanel_LHSPointFeaturesDataTable extends javax.swing.JPanel
                                              implements TableModelListener {
    
    /** the FeatureCollection on which the TableModel is based */ 
    protected FeatureCollection fcFeatures = null;
    /** the TableModel underlying the JTable */
    protected LHSPointFeaturesTableModel tableModel = null;
    
    /** flag to print debugging info */
    public static boolean debug = false;
    /** logger for class */
    private static final Logger logger = Logger.getLogger(JPanel_LHSPointFeaturesDataTable.class.getName());
    
    /** Creates new form CSVDataTable_JPanel */
    public JPanel_LHSPointFeaturesDataTable() {
        initComponents();
        initComponents1();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPopupMenu = new javax.swing.JPopupMenu();
        jmiIdentify = new javax.swing.JMenuItem();
        jmiRemove = new javax.swing.JMenuItem();
        jmiUndo = new javax.swing.JMenuItem();
        jSeparator1 = new javax.swing.JPopupMenu.Separator();
        jmiHideColumns = new javax.swing.JMenuItem();
        jmiUnhideColumns = new javax.swing.JMenuItem();
        jScrollPane = new javax.swing.JScrollPane();
        jTable = new javax.swing.JTable();

        jmiIdentify.setText("Identify selected indviduals");
        jmiIdentify.setToolTipText("highlight individuals on map");
        jmiIdentify.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jmiIdentifyActionPerformed(evt);
            }
        });
        jPopupMenu.add(jmiIdentify);

        jmiRemove.setText("Remove selected individuals");
        jmiRemove.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jmiRemoveActionPerformed(evt);
            }
        });
        jPopupMenu.add(jmiRemove);

        jmiUndo.setText("Undo last edit");
        jmiUndo.setToolTipText("Undoes the last edit");
        jmiUndo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jmiUndoActionPerformed(evt);
            }
        });
        jPopupMenu.add(jmiUndo);
        jPopupMenu.add(jSeparator1);

        jmiHideColumns.setText("Hide columns");
        jmiHideColumns.setToolTipText("minimizes the size of the selected columns");
        jmiHideColumns.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jmiHideColumnsActionPerformed(evt);
            }
        });
        jPopupMenu.add(jmiHideColumns);

        jmiUnhideColumns.setText("Unhide columns");
        jmiUnhideColumns.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jmiUnhideColumnsActionPerformed(evt);
            }
        });
        jPopupMenu.add(jmiUnhideColumns);

        jTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jTable.setCellSelectionEnabled(true);
        jTable.setComponentPopupMenu(jPopupMenu);
        jScrollPane.setViewportView(jTable);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void jmiIdentifyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jmiIdentifyActionPerformed
        if (debug) logger.info("IdentifyAction called on "+jTable.getSelectedRow());
    }//GEN-LAST:event_jmiIdentifyActionPerformed

    private void jmiRemoveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jmiRemoveActionPerformed
        int[] rows = jTable.getSelectedRows();
        FeatureCollection fc = tableModel.removeRows(rows);
        fcFeatures.removeAll(fc);//remove features from the FeatureCollection on which the tale is based
        if (debug) logger.info("removed selected rows");
    }//GEN-LAST:event_jmiRemoveActionPerformed

    private void jmiHideColumnsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jmiHideColumnsActionPerformed
        for (int col : jTable.getSelectedColumns()){
            jTable.getColumnModel().getColumn(col).setPreferredWidth(1);
        }
    }//GEN-LAST:event_jmiHideColumnsActionPerformed

    private void jmiUnhideColumnsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jmiUnhideColumnsActionPerformed
        int[] cols = jTable.getSelectedColumns();
        for (int col : cols){
            TableColumn tc = jTable.getColumnModel().getColumn(col);
            tc.setPreferredWidth(((String)tc.getHeaderValue()).length()*10);
        }
    }//GEN-LAST:event_jmiUnhideColumnsActionPerformed

    private void jmiUndoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jmiUndoActionPerformed
        int editType = tableModel.getLastEditType(); 
        if (debug) logger.info("UndoAction: edit action = "+((editType==LHSPointFeaturesTableModel.EDIT_ADD) ? "undoing add" : "undoing remove"));
        FeatureCollection fc = tableModel.undoLastEdit();
        if (editType==LHSPointFeaturesTableModel.EDIT_ADD){
            //undo removed returned features from table, 
            //so remove them from the original FeatureCollection also
            fcFeatures.removeAll(fc);
        } else if (editType==LHSPointFeaturesTableModel.EDIT_REMOVE){
            //undo added returned features to table, 
            //so add them to original FeatureCollection also
            fcFeatures.addAll(fc);
        }
    }//GEN-LAST:event_jmiUndoActionPerformed
 
    private void initComponents1(){
//        PopupListener pl = new PopupListener();
//        jTable.addMouseListener(pl);
    }
    
    /**
     * Returns the last type of edit on the table.
     * 
     * @return 
     */
    public int getLastEditType(){
        return tableModel.getLastEditType();
    }
    
    /**
     * Returns the last features edited on the table.
     * 
     * @return 
     */
    public FeatureCollection getLastEditedFeatures(){
        return tableModel.getLastEditedFeatures();
    }
    
    /**
     * Adds a feature to the table model.
     * 
     * @param f - the feature to add
     */
    public void add(Feature f){
        if (debug) logger.info("Added feature");
        tableModel.add(f);
        jTable.repaint();
    }
 
    /**
     * Adds a collection of features to the table model.
     * 
     * @param fc - the collection to add 
     */
    public void addAll(FeatureCollection fc){
        if (debug) logger.info("Added collection");
        tableModel.addAll(fc);
        jTable.repaint();
    }
 
    /**
     * Removes a feature from the table model.
     * 
     * @param f - the feature to be removed
     */
    public void remove(Feature f){
        if (debug) logger.info("Removed feature");
        tableModel.remove(f);
        jTable.repaint();
    }
 
    /**
     * Adds a collection of features from the table model.
     * 
     * @param fc - the collection of features to be removed
     */
    public void removeAll(FeatureCollection fc){
        if (debug) logger.info("Removed collection");
        tableModel.removeAll(fc);
        jTable.repaint();
    }
    
    /**
     * Returns the table model
     * @return 
     */
    public TableModel getTableModel(){
        return tableModel;
    }
    
    /**
     * Tests whether the instance of this class has had a TableModel created.
     * 
     * @return 
     */
    public boolean hasTableModel(){
        return (tableModel!=null);
    }

    /**
     * Creates a LHSPointFeaturesTableModel.
     * @param ft
     * @param fc 
     */
    public void createTableModel(LHSPointFeatureType ft, FeatureCollection fc) throws IOException{
        fcFeatures = fc;
        tableModel = new LHSPointFeaturesTableModel(ft,fc);
        jTable.setModel(tableModel);
        jTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        TableColumnModel tcm = jTable.getColumnModel();
        for (int c=0;c<tcm.getColumnCount();c++){
            TableColumn tc = tcm.getColumn(c);
            String colName = (String) tc.getHeaderValue();
            if (debug) logger.info(c+"; "+colName+"; "+tableModel.getColumnClass(c)+"; "+tableModel.getColumnKey(c));
            tc.setPreferredWidth(colName.length()*10);
        }
        jTable.validate();
        tableModel.addTableModelListener(this);
    }
    
    /**
     * Adds a TableModelListener to the table model.
     * 
     * @param l 
     */
    public void addTableModelListener(TableModelListener l){
        tableModel.addTableModelListener(l);
    }
    
    /**
     * Removes a TableModelListener to the table model.
     * 
     * @param l 
     */
    public void removeTableModelListener(TableModelListener l){
        tableModel.removeTableModelListener(l);
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPopupMenu jPopupMenu;
    private javax.swing.JScrollPane jScrollPane;
    private javax.swing.JPopupMenu.Separator jSeparator1;
    private javax.swing.JTable jTable;
    private javax.swing.JMenuItem jmiHideColumns;
    private javax.swing.JMenuItem jmiIdentify;
    private javax.swing.JMenuItem jmiRemove;
    private javax.swing.JMenuItem jmiUndo;
    private javax.swing.JMenuItem jmiUnhideColumns;
    // End of variables declaration//GEN-END:variables

    @Override
    public void tableChanged(TableModelEvent e) {
        if (debug) logger.info("tableChanged: "+e.toString());
    }
    
    private class PopupListener extends MouseAdapter {
        @Override
        public void mousePressed(MouseEvent e) {
            maybeShowPopup(e);
        }

        @Override
        public void mouseReleased(MouseEvent e) {
            maybeShowPopup(e);
        }

        private void maybeShowPopup(MouseEvent e) {
            if (e.isPopupTrigger()) {
                jPopupMenu.show(e.getComponent(), e.getX(), e.getY());
            }
        }
    }
    
}
