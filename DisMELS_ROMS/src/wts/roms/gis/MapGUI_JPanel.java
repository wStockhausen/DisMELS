/*
 * MapGUI_JPanel.java
 *
 * Created on December 30, 2005, 1:58 PM
 */

package wts.roms.gis;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.geom.Dimension2D;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.IOException;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.JOptionPane;
import javax.swing.UIManager;
import org.geotools.cs.CoordinateSystem;
import org.geotools.ct.MathTransform;
import org.geotools.feature.FeatureCollection;
import org.geotools.feature.IllegalAttributeException;
import org.geotools.feature.SchemaException;
import org.geotools.gui.swing.Legend;
import org.geotools.map.DefaultMapContext;
import org.geotools.map.DefaultMapLayer;
import org.geotools.map.MapContext;
import org.geotools.map.MapLayer;
import org.geotools.renderer.j2d.GeoMouseEvent;
import org.geotools.renderer.j2d.RenderedLayer;
import org.geotools.styling.Style;
import org.geotools.styling.StyleBuilder;
import org.opengis.referencing.operation.TransformException;
import org.openide.util.Exceptions;
import wts.models.utilities.DateTime;
import wts.roms.gui.JPanel_OceanTime;
import wts.roms.model.GlobalInfo;
import wts.roms.model.ModelGrid2D;

/**
 *
 * @author  William Stockhausen
 */
public class MapGUI_JPanel extends javax.swing.JPanel implements PropertyChangeListener {
    
    private GlobalInfo globalInfo;
    
    private ModelGrid2DMapData gridMapData;

    private MapContext context;
    private EditingMapPane mapPane;
//    private GeoMouseEvent geoMousePressed;
    private CoordinateSystem csMapView;
//    private CoordinateSystem csCoordDisplay;
    private MathTransform mtMapToDisplay;

    private MapLayer gridLayer=null;
    private MapLayer maskLayer=null;
    
    private Legend legend;
    private Dimension2D dim;
    
//    private JPanel_OceanTime oceanTimeJP;
    
    /** Creates new form MapTester */
    public MapGUI_JPanel() {
        globalInfo = GlobalInfo.getInstance();
        initComponents();
        initComponents1();
        setGrid();
        globalInfo.addPropertyChangeListener(this);
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        jpStatus = new javax.swing.JPanel();
        jtfLon = new javax.swing.JTextField();
        jtfLat = new javax.swing.JTextField();
        jtfDepth = new javax.swing.JTextField();
        jtfStatus = new javax.swing.JTextField();
        splitPane = new javax.swing.JSplitPane();
        jpLegend = new javax.swing.JPanel();
        jpDrawing = new javax.swing.JPanel();
        jpMapPanel = new javax.swing.JPanel();
        oceanTimeJP = new wts.roms.gui.JPanel_OceanTime();

        setLayout(new java.awt.BorderLayout());

        jpStatus.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        jpStatus.setMinimumSize(new java.awt.Dimension(100, 25));
        jpStatus.setPreferredSize(new java.awt.Dimension(100, 25));
        jpStatus.setRequestFocusEnabled(false);
        jtfLon.setEditable(false);
        jtfLon.setHorizontalAlignment(javax.swing.JTextField.LEFT);
        jtfLon.setToolTipText("longitude");

        jtfLat.setEditable(false);
        jtfLat.setHorizontalAlignment(javax.swing.JTextField.LEFT);
        jtfLat.setToolTipText("latitude");

        jtfDepth.setEditable(false);
        jtfDepth.setToolTipText("depth (m)");

        jtfStatus.setEditable(false);
        jtfStatus.setText("Status");

        org.jdesktop.layout.GroupLayout jpStatusLayout = new org.jdesktop.layout.GroupLayout(jpStatus);
        jpStatus.setLayout(jpStatusLayout);
        jpStatusLayout.setHorizontalGroup(
            jpStatusLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jpStatusLayout.createSequentialGroup()
                .add(jtfStatus, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 86, Short.MAX_VALUE)
                .add(33, 33, 33)
                .add(jtfLon, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 166, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jtfLat, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 166, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jtfDepth, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 166, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
        );
        jpStatusLayout.setVerticalGroup(
            jpStatusLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jpStatusLayout.createSequentialGroup()
                .add(jpStatusLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jtfDepth, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(jtfLat, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(jtfLon, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(jtfStatus, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        add(jpStatus, java.awt.BorderLayout.SOUTH);

        org.jdesktop.layout.GroupLayout jpLegendLayout = new org.jdesktop.layout.GroupLayout(jpLegend);
        jpLegend.setLayout(jpLegendLayout);
        jpLegendLayout.setHorizontalGroup(
            jpLegendLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 100, Short.MAX_VALUE)
        );
        jpLegendLayout.setVerticalGroup(
            jpLegendLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 284, Short.MAX_VALUE)
        );
        splitPane.setLeftComponent(jpLegend);

        jpDrawing.setLayout(new java.awt.BorderLayout());

        jpDrawing.setBackground(new java.awt.Color(204, 204, 204));
        jpMapPanel.setLayout(new java.awt.BorderLayout());

        jpMapPanel.setMinimumSize(new java.awt.Dimension(100, 100));
        jpMapPanel.setPreferredSize(new java.awt.Dimension(100, 100));
        jpDrawing.add(jpMapPanel, java.awt.BorderLayout.CENTER);

        jpDrawing.add(oceanTimeJP, java.awt.BorderLayout.NORTH);

        splitPane.setRightComponent(jpDrawing);

        add(splitPane, java.awt.BorderLayout.CENTER);

    }// </editor-fold>//GEN-END:initComponents
    
    private void initComponents1() {
        //Create map coordinate system
        PrimeMeridian.setPrimeMeridian(PrimeMeridian.PM_GREENWICH);
        try {
            csMapView = 
                    AlbersNAD83.getAlbers();
//            csCoordDisplay =
//                    AlbersNAD83.getNAD83();
            mtMapToDisplay = AlbersNAD83.getPtoGtransform();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        
        //Create map context to hold map layers
        context = new DefaultMapContext();
        //Create a StyledMapPane and add it to the JPanel with a scroll pane
        mapPane = new EditingMapPane(csMapView);
        jpMapPanel.add(mapPane.createScrollPane());
        //hook up mouse listeners
        mapPane.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                geoMouseMoved(evt);
            }
        });

        //Set Add/Zoom to Zoom to start
        setMouseDragZooms(true);
        //disable input methods until grid file is set
        mapPane.enableInputMethods(false);
        
        //make sure Legend has icons it needs
        Icon open = UIManager.getIcon("Tree.openIcon");
        if (open==null) {
            Icon icon= new javax.swing.ImageIcon(getClass().getResource("/wts/roms/gui/resources/icons/Open16.gif"));
            UIManager.put("Tree.openIcon", icon);
        }
        
        legend = new Legend(context,"Layers");
        splitPane.setLeftComponent(legend);
        
//        jpMapPanel.setBackground(null);
//        jpMapGraphics.setBackground(null);
//        jpMapGraphics.set
//        jpMapGraphics.setOpaque(false);
        dim = new Dimension2D(){
            private double w = 1.0e-5;//old value 1.0e-5
            private double h = 1.0e-5;
            @Override
            public double getWidth() {return w;}

            @Override
            public double getHeight() {return h;}

            @Override
            public void setSize(double width, double height) {
                w = width; h = height;
            }

        };
    }
    
    private void setContext(){
        try {
            mapPane.reset();
            mapPane.setMapContext(context);
            RenderedLayer[] rls = mapPane.getRenderer().getLayers();
            for (RenderedLayer rl: rls){
                rl.setPreferredPixelSize(dim);
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
    
    /**
     * Adds layer to "top" of existing layers so that it is painted AFTER all
     * other layers.
     * @param layer
     */
    public void addLayer(MapLayer layer) {
        context.addLayer(layer);
        if (mapPane.getMapContext()!=null) return;//only set context if not already set
        setContext();
    }

    /**
     * Adds layer at index idx of existing layers so that it is the idx-th layer
     * painted.
     * @param idx - 0-based order at which added layer should be painted
     * @param layer
     */
    public void addLayer(int idx, MapLayer layer) {
        context.addLayer(idx,layer);
        if (mapPane.getMapContext()!=null) return;//only set context if not already set
        setContext();
    }

    /**
     * Adds layer to "bottom" of existing layers so that it is painted BEFORE all
     * other layers.
     * @param layer
     */
    public void addLayerAtBottom(MapLayer layer) {
        context.addLayer(0, layer);//add as 1st element in context, as this gets painted first
        MapLayer[] mls = context.getLayers();
        for (int i=0;i<mls.length;i++) {
            System.out.println("layer "+i+" is '"+mls[i].getTitle()+"'");
        }
        if (mapPane.getMapContext()!=null) return;//only set context if not already set
        setContext();
    }

    @Override
    public void addMouseListener(MouseListener listener) {
        mapPane.addMouseListener(listener);
    }
    
    @Override
    public void addMouseMotionListener(MouseMotionListener listener) {
        mapPane.addMouseMotionListener(listener);
    }
    
    public ModelGrid2DMapData getGridMapData() {
        return gridMapData;
    }
    
    public Image getMapAsImage() {
        int width      = jpDrawing.getWidth();
        int height     = jpDrawing.getHeight();
        Image img      = jpDrawing.createImage(width,height);
        Graphics grImg = img.getGraphics();
        jpDrawing.paintComponents(grImg);
//        jpDrawing.paintAll(grImg);
        return img;
    }
    
    public BufferedImage getMapAsBufferedImage() {
        int width      = jpDrawing.getWidth();
        int height     = jpDrawing.getHeight();
        BufferedImage bi = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);
        Graphics2D grBI = bi.createGraphics();
        jpDrawing.paintComponents(grBI);
//        jpDrawing.paintAll(grImg);
        return bi;
    }
    
    public void saveMapAsImage(File f) throws IOException {
        String fName = f.getName();
        String ext = fName.substring(fName.length()-3);//get extension
        BufferedImage bi = getMapAsBufferedImage();
        ImageIO.write(bi,ext,f);
    }
    
    public void saveMapAsImage(String fName) throws IOException {
        String ext = fName.substring(fName.length()-3);//get extension
        BufferedImage bi = getMapAsBufferedImage();
        File f = new File(fName);
        ImageIO.write(bi,ext,f);
    }
    
    /**
     * Interpolates the bathymetric depth grid to the input
     * lat, lon coordinates.
     *
     *@param lon - GIS longitude (deg) with PM Greenwich, -180 to 180
     *@param lat - GIS latitude (deg), -90 to 90
     *@return - bathymetric depth (d > 0)
     *TODO - longitude is currently expected to be relative to the IDL, not
     *       Greenwich.  Want to change this when we get coordinate systems
     *       figured out.
     */
    public double interpolateBathymetricDepth(double x,double y) {
        double z = gridMapData.interpolateBathymetricDepth(x,y);
        return z;
    }
    
    private void geoMouseMoved(java.awt.event.MouseEvent evt) {
        if ((gridLayer!=null)&&(evt instanceof GeoMouseEvent)) {
            GeoMouseEvent gme = null;
            gme = (GeoMouseEvent) evt;
            Point2D dest = gme.getMapCoordinate(null);
            try {
                //transform from map coordinates to display coordinates
//                jtfLat.setText(String.valueOf(dest.getY()));
//                double x = dest.getX()+180*MathFunctions.isTrue(PrimeMeridian.getPrimeMeridian()==PrimeMeridian.PM_IDL);
//                if (x>180) x=x-360;
//                jtfLon.setText(String.valueOf(x));
//                double z = gridMapData.interpolateBathymetricDepth(PrimeMeridian.adjustToROMSlon(dest.getX()),
//                                                                   dest.getY());
                double[] srcPt = new double[]{dest.getX(),dest.getY()};
                double[] dstPt = new double[2];
                mtMapToDisplay.transform(srcPt,0,dstPt,0,1);
                jtfLat.setText(String.valueOf(dstPt[1]));
                jtfLon.setText(String.valueOf(dstPt[0]));
                double z = 
                        gridMapData.interpolateBathymetricDepth(dstPt[0],dstPt[1]);
                jtfDepth.setText(String.valueOf(z));
            } catch(ArrayIndexOutOfBoundsException exc) {
                //do nothing
            } catch (org.opengis.referencing.operation.TransformException ex) {
                ex.printStackTrace();
            }
        }
    }

    public MapContext getContext() {
        return context;
    }
    
    public EditingMapPane getMapPane() {
        return mapPane;
    }

    /**
     * Maps the GlobalInfo grid
     */
    public void setGrid() {
        if (gridLayer!=null) context.clearLayerList();
        ModelGrid2D mg = globalInfo.getGrid();
        if (mg!=null){
            try {
                //create the grid and mask MapLayers
                FeatureCollection fc;
                Style style;
                StyleBuilder sb = new StyleBuilder();

                //Make the grid fc
                gridMapData = new ModelGrid2DMapData();
                fc = gridMapData.getGridLines(5);
                System.out.println("line bounds: "+fc.getBounds().toString());
    //            System.out.println("grid coordinate system: "+
    //                    fc.getFeatureType().getDefaultGeometry().getCoordinateSystem().getName());
                style = sb.createStyle(sb.createLineSymbolizer(Color.RED,1.0));
                gridLayer = new DefaultMapLayer(fc,style,"model grid");
                context.addLayer(gridLayer);

                //and the mask fc
                fc = gridMapData.getMask();
                System.out.println("polygon bounds: "+fc.getBounds().toString());
                style = sb.createStyle(sb.createPolygonSymbolizer(Color.GRAY));
                maskLayer = new DefaultMapLayer(fc,style,"land mask");
                context.addLayer(maskLayer);

                setContext();
                validate();
                //enable input methods on mapPane
                mapPane.enableInputMethods(true);
            } catch (IllegalAttributeException ex) {
                Exceptions.printStackTrace(ex);
            } catch (SchemaException ex) {
                Exceptions.printStackTrace(ex);
            } catch (Exception ex) {
                Exceptions.printStackTrace(ex);
            }
        } else {
            //enable input methods on mapPane
            mapPane.enableInputMethods(false);
        }
    }
    
    public boolean getMouseDragZooms() {
        return mapPane.getMouseDragZooms();
    }
    
    public void setMouseDragZooms(boolean b) {
        mapPane.setMouseDragZooms(b);
    }
 
    public void setStatusString(String s) {
        jtfStatus.setText(s);
    }
    
    public JPanel_OceanTime getOceanTimeJP() {
        return oceanTimeJP;
    }
    
    public void setOceanTime(long time) {
        oceanTimeJP.setOceanTime(time);
    }
    
    public void setOceanTime(double time) {
        oceanTimeJP.setOceanTime(time);
    }
    
    public void setOceanTime(DateTime dt) {
        oceanTimeJP.setDateTime(dt);
    }
    
    public void setOceanTimeVisible(boolean b) {
        oceanTimeJP.setVisible(b);
    }
    
    public DateTime getRefDate() {
        return oceanTimeJP.getRefDate();
    }
    public void setRefDate(DateTime dt) {
        oceanTimeJP.setRefDate(dt);
    }
    
    public double[] transformFromMapCStoDisplayCS(double[] mapPt) throws TransformException {
        double[] dspPt = new double[mapPt.length];
        mtMapToDisplay.transform(mapPt,0,dspPt,0,1);
        return dspPt;
    }

    public void removeLayer(MapLayer layer) {
        context.removeLayer(layer);
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel jpDrawing;
    private javax.swing.JPanel jpLegend;
    private javax.swing.JPanel jpMapPanel;
    private javax.swing.JPanel jpStatus;
    private javax.swing.JTextField jtfDepth;
    private javax.swing.JTextField jtfLat;
    private javax.swing.JTextField jtfLon;
    private javax.swing.JTextField jtfStatus;
    private wts.roms.gui.JPanel_OceanTime oceanTimeJP;
    private javax.swing.JSplitPane splitPane;
    // End of variables declaration//GEN-END:variables

    @Override
    public void propertyChange(PropertyChangeEvent pce) {
        if (pce.getSource().equals(globalInfo)){
            if (pce.getPropertyName().equals(GlobalInfo.PROP_GridFile)){
                setGrid();
            }
        }
    }
    
}
